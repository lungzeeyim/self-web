---
title: MySQL + JDBC
tags:
- job
---

## BASIC
1. 什么是关系型数据库？ 
    - 关系型数据库是以关系模型（表）为基础的数据管理系统
    - 采用结构化查询语言（SQL）进行数据的操作和管理。
1. 什么是非关系型数据库？ 
    - 以键值对、文档、列族等形式来组织和管理数据。
    - 非关系型数据库适用于大规模、高并发的数据存储和访问场景
1. 数据库 三大范式
    - 1NF：列(column) 不可再分
    - 2NF: 不存在 部分 函数依赖，每个 非主键 column 依赖于 主键。
    - 3NF: 不存在 传递依赖，每个 非主键column 直接依赖于 主键。
1. SQL？ 
    - SQL（Structured Query Language）是结构化查询语言，用于管理和操作关系型数据库。
    - 它包含了
        - 数据定义（DDL）
        - 数据操作（DML）
        - 数据查询（DQL）和
        - 数据控制（DCL）等语句。
1. ACID特性？ 
    - ACID（原子性、一致性、隔离性、持久性）是数据库事务的四个特性。
    - 原子性表示事务中的操作要么全部执行成功，要么全部失败
    - 一致性表示事务执行后，数据库从一个一致状态转移到另一个一致状态
    - 隔离性表示并发执行的事务之间是相互隔离的
    - 持久性表示事务一旦提交，对数据的改变是永久的。
1. 什么是事务？ 
    - 事务是指由一个或多个操作组成的一个工作单位，要么全部执行成功，要么全部失败。
    - 事务具有原子性、一致性、隔离性和持久性四个特性，可以通过事务管理来保证数据的完整性和一致性。
    - 在关系型数据库中，
        - 事务由事务开始（BEGIN）、事务提交（COMMIT）和事务回滚（ROLLBACK）来控制。

## 表操作
1. 主键？ 
    - 主键（Primary Key 用来 唯一标识 表中 每条记录
    - 值必须是 唯一的 且 不为空。
1. 外键？ 
    - 外键（Foreign Key）用于在 一个表中 创建 对另一个表 `主键的引用`
    - 它用于建立表与表之间的关系。
1. 什么是索引？ 
    - 索引（Index）是一种数据结构
    - 用于加快对表中数据的查找速度
    - 它类似于书的目录
1. 唯一索引？ 
    - 唯一索引（Unique Index）是一种索引
    - 用于确保 被索引的 column 的值 是唯一的，即不允许重复的值。
1. 主键索引？ 
    - 主键索引（Primary Key Index）是一种特殊的唯一索引，用于对主键字段进行索引。
    - 主键索引的作用是确保主键的唯一性，同时也会加速对主键的查询操作。
1. 如何创建索引？ 
    - 创建索引可以使用ALTER TABLE语句
      ```sql
      -- 创建唯一索引
      ALTER TABLE table_name ADD UNIQUE index_name(column1);
      -- 创建主键索引
      ALTER TABLE table_name ADD PRIMARY KEY (column1);
      ```
1. 删除索引？ 
    - 使用ALTER TABLE语句
    - 删除唯一索引
      ```sql
      ALTER TABLE table_name DROP INDEX index_name
      ```
    - 删除主键索引
      ```sql
      ALTER TABLE table_name DROP PRIMARY KEY;
      ```

1. 如何修改表column的字段data_type？ 
    - 使用ALTER TABLE语句，使用MODIFY COLUMN子句修改表的字段定义
      ```sql
      ALTER TABLE table_name MODIFY COLUMN column_name new_data_type;
      ```

1. 如何删除表？ 
    - 使用DROP TABLE语句
      ```sql
      DROP TABLE table_name; 
      ```
## 索引优化

1. 为什么要使用索引？ 
    - 提高数据库查询的速度和性能
    - 减少了数据扫描的时间和IO负载。

1. 如何选择合适的索引？ 
    - 选择合适的索引, 需要 考虑 查询频率 和 查询条件的 选择性。
    - 根据 经常使用的 查询条件 创建索引 是一个好的选择
    - 避免过度索引，只 创建 最常用的 索引，以减少 索引 维护的开销。

1. 什么是索引覆盖？ 
    - 索引覆盖 是指 查询语句 可以完全通 过索引的结构 来获取需要的数据
    - 而 不需要 回表到 数据页中 获取其他列的数据
    - 通过 索引覆盖 可以减少 IO操作 和 提高查询性能

1. 什么是联合索引？ 
    - 联合索引（Composite Index）
    - 指由多个column 组合在一起创建的索引
    - 联合索引 可以优化 同时查询多个列的条件，提高查询的效率。

1. 最左前缀原则？ 
    - 是指在联合索引中，索引的顺序非常重要。
    - 索引 按照 从左到右的 顺序 逐步缩小检 索范围，以提高查询性能
    - 如果 查询条件中的 column 顺序 不符合 索引的顺序，将无法使用到索引的优势。

1. 什么是索引失效？ 
    - 索引 无法被 查询语句 有效利用，导致无法提高查询性能
    - 使用不符合索引顺序的查询条件
    - 类型转换 导致 无法使用索引等

1. 什么是 覆盖索引？ 
    - 覆盖索引 是指 索引 包含 所有查询所需的column，不需要回表 查询数据页
    - 通过 覆盖索引 提高查询性能。 

## 性能优化
- 如何优化查询语句的性能？
    - 选择合适的索引，减少全表扫描的开销。
    - 避免使用SELECT *，只选择需要的列。
    - 使用JOIN时，确保连接字段有索引。
    - 避免使用子查询，尽量使用JOIN操作。
    - 使用LIMIT限制返回的行数。
- 如何优化表的结构？
    - 根据业务需求和查询模式设计合适的表结构。
    - 避免使用过多的字段，只留下必要的列。
    - 对经常用于查询的字段创建索引。
    - 合理使用数据类型，尽量避免使用过大的数据类型。
    - 根据实际情况拆分大表，减少单表数据量。
- 如何优化连接查询的性能？
    - 确保连接字段有索引。
    - 调整连接表的顺序，将结果集较小的表放在前面。
    - 避免在连接查询中使用不必要的column
    - 尽量避免使用多表连接查询，考虑使用其他方式，如子查询、临时表等。
- 什么是查询缓存？如何使用查询缓存？ 
    - 查询缓存是MySQL的一个功能，用于缓存查询语句的结果集。
    - 通过开启查询缓存，MySQL可以在执行查询之前检查查询语句是否已经执行过，并且结果是否在缓存中。
    - 可以使用以下语句来开启或禁用查询缓存：
        - 开启查询缓存：SET GLOBAL query_cache_size = {缓存大小};
        - 禁用查询缓存：SET GLOBAL query_cache_type = OFF;
 什么是分库分表？ 分库分表是指将一个大型数据库拆分成多个小型数据库或表，用于分散数据存储和提高查询性能。分库分表可以根据实际业务需要将数据根据某种规则进行划分，如按照用户ID、时间等进行水平拆分。
 如何进行分页查询？ 分页查询可以使用LIMIT语句来实现。例如，LIMIT 10 OFFSET 20 表示返回第21到第30行的结果。
 如何进行分组和排序查询？

## 性能优化工具
- 如何使用Explain分析查询语句的性能？
    - 使用语句可以分析查询语句的执行计划，了解查询过程中使用的索引、表的读取顺序以及可能存在的优化问题。
    ```sql
    EXPLAIN SELECT * FROM employees WHERE department_id = 10;
    ```
    - 执行该语句后，MySQL将返回一张描述查询计划的结果表。在结果表中，你可以关注以下几个重要的列：
        - id：表示查询中不同操作的标识符，可以用于确定操作的顺序和嵌套关系。
        - select_type：表示查询的类型，主要有SIMPLE、PRIMARY、SUBQUERY、DERIVED等。
        -  table：表示涉及的表名。
        -  type：表示MySQL执行查询时使用的访问方法，例如全表扫描（ALL）、索引扫描（index）等。
        - key：表示查询使用的索引名称。
        - rows：表示MySQL估计需要扫描的行数。
        - Extra：可能包含一些额外的信息，如Using index（表示使用了覆盖索引）或Using temporary（表示需要使用临时表）等。 
通过分析的结果，你可以判断查询是否有效利用索引，是否存在潜在的性能问题，并根据需要对查询语句或索引进行优化。

## 数据库的水平拆分和垂直拆分
- 什么是数据库的水平拆分？
    - 数据库的水平拆分是指将一个数据表按照某个规则（如行范围、哈希等）将数据拆分存储在多个独立的数据库实例或服务器上。
    - 拆分后的表仍然保持相同的结构，但数据分散在不同的物理存储中。这种拆分方式通常用于处理大量数据的负载均衡，提高数据库的并发能力和扩展性。
    - 例如，将一个包含用户信息的数据表按照用户ID的哈希值进行拆分，其中一部分用户数据存储在数据库A中，另一部分存储在数据库B中。当应用程序需要访问特定用户的数据时，可以根据哈希算法快速定位到对应的数据库实例进行查询，分担单个数据库的查询压力。
- 什么是数据库的垂直拆分？
    - 数据库的垂直拆分是指将一个数据表按照其列进行拆分，将不同的列分配到不同的数据库实例或服务器上。
    - 拆分后的表结构可能不同，每个部分通常只包含所需的列，以满足不同的应用程序需求。这种拆分方式通常用于解决复杂的查询需求和降低数据库的规模和复杂性。 
    - 举个例子，假设有一个包含用户信息的数据表，其中包含用户的基本信息和订单信息。通过垂直拆分，可以将用户的基本信息和订单信息分别存储在不同的数据表中，例如一个用于存储用户的基本信息的表和一个用于存储用户的订单信息的表。这种拆分方式可以减少查询时的冗余数据，提高查询性能和数据的可维护性。

## 数据库的 分库 分表
- 什么是数据库的分库分表？
    - 数据库的分库分表是一种常见的数据库拆分策略，用于解决大规模应用中数据规模和负载的扩展需求。
    - 在分库分表中，数据被分散存储在多个独立的数据库实例或服务器上，既可以水平拆分，也可以垂直拆分。
    - 分库分表可以提高数据库的并发能力、扩展性和性能。

- 如何进行数据库的分库分表？数据库的分库分表可以通过以下步骤进行：
    - 分析需求：评估数据库的性能需求、负载情况和数据规模，以确定是否需要进行分库分表。这个过程需要考虑到数据的增长趋势和业务的拓展需求。
    - 制定拆分策略：根据需求分析的结果，制定适合的分库分表策略。
        - 可以选择水平拆分还是垂直拆分，以及具体的拆分方案，
        - 如按照数据范围、哈希值、业务功能等进行分割。
    - 创建数据库和数据表：根据拆分策略，在相应的数据库实例或服务器上创建分库和分表。每个分库可以是一个独立的数据库实例，每个分表可以是一个独立的数据表。

## 事务的四大特性
- 事务的四大特性是什么？分别解释一下。
    - 事务的四大特性是ACID，分别是
        - 原子性（Atomicity）：原子性指一个事务是不可分割的最小操作单位。事务中的操作要么全部成功执行（提交），要么全部失败（回滚），不会出现部分操作成功部分操作失败的情况。保证事务的原子性可以防止数据的不一致性。
        - 一致性（Consistency）：一致性指事务执行前后，数据库的状态保持一致。即事务执行前后，数据必须符合预定义的规则、约束和完整性规定。如果一个事务破坏了数据库的一致性，系统将会回滚该事务，使数据库恢复到一致的状态。
        - 隔离性（Isolation）：隔离性指多个事务并发执行时，每个事务都应该被隔离开，不应相互影响。每个事务在执行期间对数据所做的修改在提交之前对其他事务是不可见的，其他事务也无法对其进行访问。隔离级别提供了多种不同的隔离级别，如读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable），用于控制事务之间的隔离程度。
        - 持久性（Durability）：持久性指一个事务一旦提交，其所做的修改将永久保存在数据库中，并且不会受到系统故障的影响。即使系统发生故障，数据库也应该能够通过日志恢复机制将数据恢复到事务提交后的状态。持久性保证了数据的持久存储和可靠性。
这些事务的特性一起确保了数据库的完整

## 数据库的锁机制

- 数据库的锁机制可以分为两种主要类型：悲观锁和乐观锁。
    - 悲观锁（Pessimistic Locking）：悲观锁是一种保守的锁机制，假设会发生并发冲突，因此在事务操作期间会锁定资源，以防止其他事务对该资源的修改。
        - 悲观锁通常实现为共享锁（Shared Lock）和排他锁（Exclusive Lock）。
        - 共享锁（Shared Lock）：也称为读锁，多个事务可以同时获得共享锁，但是阻止其他事务获取排他锁。共享锁允许并发读取操作，但防止了并发写操作，以确保数据的一致性。共享锁是一种可重复读隔离级别（如MySQL的InnoDB默认隔离级别）的实现方式。
        - 排他锁（Exclusive Lock）：也称为写锁，只有一个事务可以获取排他锁，其他事务无法获取共享锁或排他锁。排他锁阻塞了其他事务的读写操作，直到该事务完成并释放锁。排他锁保证了事务的完整性和一致性，是一种串行化隔离级别的实现方式。
    - 乐观锁（Optimistic Locking）：乐观锁是一种乐观的锁机制，假设并发冲突是不常见的，因此在事务操作期间不会锁定资源。相反，它通过使用版本号（Version）或时间戳（Timestamp）来解决并发冲突。如果两个事务同时更新同一个资源，乐观锁会比较版本号或时间戳，如果冲突则中止其中一个事务，让事务重新尝试操作。
        - 乐观锁通过减少锁的使用来提高并发性能，适用于并发读取较多、并发冲突较少的场景。常见的乐观锁实现方式包括基于版本号的锁和基于时间戳的锁。

## 数据库的并发控制
- 数据库的并发控制策略有哪些？分别解释一下。
    - 锁机制：通过使用锁来控制并发访问。可以分为悲观锁和乐观锁两种类型。
        - 悲观锁在操作之前会先获取锁，以防止其他事务的干扰。
        - 乐观锁则假设并发冲突是罕见的，不会加锁而是在操作完成时进行冲突检测。
    - 串行化隔离级别：将并发操作串行执行，确保每个事务独立运行。这是一种非常严格的并发控制策略，可以通过数据库的隔离级别来实现。
    - 多版本并发控制（MVCC）：基于乐观并发控制的一种策略，通过为每个事务创建不同的版本来避免冲突。每个事务只会读取自己的版本，从而不会阻塞其他事务的读操作。
    - 时间戳排序（Timestamp Ordering）：给每个事务分配一个时间戳，在并发执行时根据时间戳的顺序进行调度，保证较早开始的事务先执行。这样可以避免一些并发冲突，提高并发性能。
    - 两阶段锁协议（Two-Phase Locking）：确保事务的临界区在加锁时先获取锁，解锁时再释放锁。该协议具有保证一致性和可串行化的特点。
    - 快照隔离（Snapshot Isolation）：每个事务在开始时获取数据的快照，并在事务执行期间保持一致性。通过快照隔离可以避免一些并发冲突和锁竞争。

## 数据库的乐观锁和悲观锁

- 什么是乐观锁和悲观锁？分别解释一下。
    - 并发控制中两种不同的策略。
    - 乐观锁（Optimistic Locking）：
        - 乐观锁是一种假设并发冲突较少的策略。
        - 在乐观锁机制下，事务在读取数据时不会加锁，而是在提交更新之前检查数据是否被其他事务修改过。
        - 乐观锁的实现方式通常是通过记录版本号（Version）或时间戳（Timestamp）。
        - 在读取数据时，事务会获取当前记录的版本号或时间戳，并在更新时进行比较
        - 如果检测到其他事务已经修改了数据，则当前事务会放弃更新并进行相应的处理（如回滚或重试）。
        - 乐观锁的优势在于减少了锁的使用，提高了并发性能。但它也有可能导致更多的冲突检测和事务重试。

    - 悲观锁（Pessimistic Locking）[ˌpesɪˈmɪstɪk]
        - 悲观锁是一种保守的策略，假设会发生并发冲突。
        - 在悲观锁机制下，事务在读取数据时会加锁，以防止其他事务修改相同的数据。
        - 悲观锁可以分为共享锁（Shared Lock）和排他锁（Exclusive Lock）两种类型
            - 共享锁允许多个事务同时读取数据，但阻止其他事务获取排他锁来修改数据
            - 而排他锁只允许一个事务独占地获取锁，其他事务无法同时读取或修改数据。
            - 悲观锁的优势在于确保了数据的一致性和完整性，但它也会造成并发性能的降低，特别是在高并发环境下可能会导致锁竞争和阻塞。

## 数据库的死锁和死锁分析

- 什么是数据库的死锁？如何进行死锁分析？
    - 数据库的死锁是指两个或多个事务相互等待对方释放资源的情况，导致所有事务无法继续执行，并陷入无限等待的状态。这种情况下，没有外部干预，事务将无法继续执行下去，从而导致系统的停滞。
    - 进行死锁分析的步骤如下：
        - 检测死锁：数据库管理系统通常提供了死锁检测机制来自动检测死锁的发生。一旦检测到死锁，数据库将记录相关信息以供分析。
        - 确定死锁的进程和资源：通过查看死锁检测的结果，确定哪些进程（事务）发生了死锁，并且哪些资源被这些进程所持有。
        - 构建死锁图：将死锁的进程和资源以及它们的依赖关系绘制成图形，形成死锁图。死锁图可以帮助我们更好地理解死锁发生的原因和资源之间的关系。
        - 解决死锁：一旦识别出死锁的原因，就可以采取相应的措施来解决死锁。常用的解决方案包括 回滚其中一个或多个事务、通过 释放资源打破死锁链等。
            - 此外，还可以通过调整并发控制策略、优化查询或重新设计数据库模型等方式来减少死锁的发生。
        - 预防死锁：
            - 除了解决死锁外，还应该采取措施预防死锁的发生。这可以通过合理的并发控制策略、良好的数据库设计、避免长时间事务的运行等方式来实现。
            - 死锁分析需要借助数据库管理系统提供的工具和机制来进行，以便及时检测死锁并解决问题。同时，对于大型和复杂系统，死锁分析可能需要结合其他性能分析工具和调优技术，以确保数据库的高可用性和性能。

## 数据库的主键和唯一索引
- 数据库的主键和唯一索引有什么区别？什么时候使用主键，什么时候使用唯一索引？
    - 主键和唯一索引都是用于保证数据的唯一性，但它们在一些方面有一些区别。
    - 主键是一种约束，用于唯一标识表中的每一行数据。它具有以下特点：
        - 主键是唯一且非空的。
        - 每张表只能有一个主键。
        - 主键的值在表中是唯一的，不能重复。
        - 主键可以由一个或多个列组成，这种情况下被称为复合主键。
    - 唯一索引是一种数据结构，用于确保某列或某些列的值在表中的唯一性。它具有以下特点：
        - 唯一索引的值在表中是唯一的，不能重复。
        - 每张表可以有多个唯一索引。
        - 唯一索引可以由一个或多个列组成，称为复合唯一索引。
    - 主键和唯一索引的共同点是都能够确保数据的唯一性。它们的区别在于：
        - primary key
            - 主键约束是对表的整体数据起作用，用于唯一标识一行数据，
            - 主键是一种逻辑概念，表的主键 用于在关系数据库中建立关系
            - 对表中的 某列或某些列进行唯一性约束，并且这个约束对整张表都具备重要性时，应该使用主键。
            - 主键不仅保证了数据的唯一性，而且可以在关系数据库中建立表与表之间的关系。
        - index
            - 唯一索引可以单独对某个列或某些列实现唯一性约束。
            - 可以加速查询，提高查询效率。
            - 当需要对表中的某列或某些列进行唯一性约束，但`这个约束不是整张表的关键时`，或者`需要加快查询效率时`，可以使用唯一索引。

## 数据库的事务隔离级别和死锁问题

- 数据库的事务隔离级别有哪些？如何解决死锁问题？
    - 数据库的事务隔离级别常见的有以下四种：
        - Read Uncommitted（读未提交）：最低级别的隔离级别，在该级别下，一个事务可以读取其他事务未提交的数据。这种隔离级别可能导致脏读（Dirty Read），即读取到未提交事务的数据。
        - Read Committed（读已提交）：每个事务只能读取其他事务已经提交的数据。这种级别避免了脏读，但可能导致不可重复读（Non-Repeatable Read），即在一个事务内进行相同的查询，但结果不一致。
        - Repeatable Read（可重复读）：在该级别下，确保同一个事务内多次查询相同数据的结果保持一致。这种级别解决了不可重复读的问题，但可能导致幻读（Phantom Read），即在同一个事务内进行相同的范围查询，但结果集不一致。
        - Serializable（串行化）：
            - 最高级别的隔离级别，要求事务串行执行，确保数据的一致性。
            - 这种级别避免了脏读、不可重复读和幻读的问题，但也降低了并发性能。

- 对于死锁问题的解决，可以考虑以下几个方面：
    - 调整事务隔离级别
        - 使用合适的事务隔离级别，可以减少死锁问题的发生。
        - 在低并发场景下可以使用Read Uncommitted级别，以减少锁的竞争。
    - 合理设计数据库事务：
        - 在编写事务操作时，尽量将事务的范围缩小为最小
        - 减少并发操作对数据的锁定。
    - 优化数据库索引：
        - 通过优化数据库索引，可以减少数据库表的锁定范围
        - 提高并发性能，减少死锁的可能性。
    - 控制并发事务数量：
        - 限制并发事务的数量，减少锁的竞争。
        - 可以通过调整数据库连接池参数、增加数据库连接数、设置事务超时时间等方式来控制并发事务的数量。
    
## 数据库的表锁和行锁

- 数据库 表锁 和 行锁 有什么区别？    
    - 表锁 和 行锁 是数据库中 用于控制 并发访问的 两种 不同级别的 锁。
    - 区别如下：
        - 表锁（Table Lock）：
            - 在表级别进行锁定，一次锁定 整个表，其他事务无法对该表进行任何修改操作。
            - 使用表锁 可以确保 并发事务 之间的 数据完整性和一致性
            - 但 牺牲了 并发性能，因为其他事务需要等待表锁释放。
        - 行锁（Row Lock）：
            - 在行级别进行锁定，即只锁定需要修改的行，其他事务仍然可以并发地访问其他行。
            - 使用行锁可以提高并发性能，但当多个事务需要锁定同一行时，可能会出现死锁的情况。
- 什么时候 使用 表锁和行锁 取决于具体的应用场景：
    - 使用表锁的情况：
        - 需要对整张表进行操作，并且并发冲突较少。
        - 需要保证整个表的一致性或数据完整性。
        - 数据库表结构发生变化，需要对整张表进行更新。
    - 使用行锁的情况：
        - 针对同一张表的 不同行 进行并发操作 的场景。
        - 并发冲突较多，需要提高并发性能。

